#include "caf/all.hpp"
#include "caf/io/all.hpp"
using namespace caf;
using namespace std;

constexpr short port = 12345;

// some data types
typedef struct color color;
struct color
{
    float r, g, b, a;
};
struct pixel_data {
    std::vector<color> pixels;
};
inline bool operator==(const pixel_data& lhs, const pixel_data& rhs) {
    return std::equal(lhs.pixels.begin(), lhs.pixels.end(), rhs.pixels.begin(), rhs.pixels.end());
}
inline bool operator==(const color& lhs, const color& rhs) {
    return 0 == std::memcmp(reinterpret_cast<const void *>(&lhs),
                            reinterpret_cast<const void *>(&rhs),
                            sizeof(color));
}

behavior server(event_based_actor* self, int port) {
    io::publish(self, port);
    return {
        [=](struct pixel_data data) {
            cout << "received: " << data.pixels.size() << " pixels" << endl;
        },
        others >> [&] () {
            cout << "others, mailbox count =" << self->mailbox().count() << endl;
        }
    };
}

int main(int argc, char *argv[]) {
    // announce the data types
    caf::announce<color>(
        "color",
        &color::r,
        &color::g,
        &color::b,
        &color::a
    );
    caf::announce<pixel_data>(
        "pixel_data",
        &pixel_data::pixels
    );

    if (argc != 2) {
        cout << "usage: " << argv[0] << " [ -server | -client ]" << endl;
    }
    string arg{argv[1]};
    scoped_actor s;
    if (arg == "-server") {
        spawn(server, port);
    }
    else if (arg == "-client") {
        actor server_proxy = io::remote_actor("127.0.0.1", port);
        pixel_data my_data;
        color white{1.0, 1.0, 1.0, 1.0};
        for (int i=0; i<1024; i++) {                  /// the problem is this, if you increase this too much, i.e. this or higher (10 works f.i.) the message won't make it, because the sender disappeared in the meantime..
            my_data.pixels.push_back(white);
        }
        s->send(server_proxy, my_data);
        /*
        using namespace std::literals;
        auto start = std::chrono::high_resolution_clock::now();
        std::this_thread::sleep_for(2s);                                  /// by uncommenting this code you can demonstrate that this is the problem, a fix is using sync_send or a full-fledged actor..
         */
    }
    s->await_all_other_actors_done();
    return 0;
}
